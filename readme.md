# Postman

## Concept
A Papers, Please inspired game where the player must validate and sort mail, adhereing to increasingly complex rules as time goes on. The story begins with the player going to the post office to forward mail to their new home in this town, when they offer to assist at the post office and become apprenticed .

The player is given the ability to open and re-seal all mail, althought they are expressly forbidden from doing so. Most mail is unreadable, but some story-driven mail is sent that the player can read. The player has the ability to send mail themselves. Initially, the options are meaningless, but reading certain story mail will open up new options. For example, after reading an incriminating letter, the player may choose to give an anonymous tip to the police.

The mail network is fully-simulated. Instead of randomly generating mail for the player to sort through, a list of senders randomly generate mail throughout the mail network every day. This adds many layers to the game. For example, the player may become familiar with the people in their town, may notice pairs of senders frequently replying to each other, etc. Mail the player sends to another town which is improperly addressed will be returned to the player marked "Undeliverable as addressed", for example.

In addition, a visualization of the map and all the mail in transit can be shown at the end of each day.

## Some Player-Facing Mechanics
The player will sort mail, either stamping it as undeliverable and putting it in the sender's box, or putting it in the recipient's box. If the recipient is in another town, the player will reference a map and forward the mail towards the post office of the appropriate town by putting it in the associated mailbox. The player will have to ensure the address is valid, that there is a stamp and that it is sufficient, that the mail is undamaged, and more. Sometimes, undeliverable mail doesn't have a return address. In these cases, the player will file the mail in the recovery bin. Mail in this bin may be subject to retrieval. For instance, a sender may submit a form requesting to recover lost mail at the player's post office. In this case, the player will search their local mail recovery bin for the post. If it isn't found, the player should forward the request to the post office that the mail being searched for would have been forwarded to.

These mechanics all become available to the player as they master previous ones. The pretext is that the postmaster will ask the player to set aside mail they don't know how to handle and will teach the player to handle more situations as the game progresses.

## Mail Simulation
The game world consists of towns. Each with a set of senders, who can generate new mail, and a post office (referred to as a mail router), which can route mail to local recipients or to other post offices. The player controls one of these mail routers.
Each day, every mail router (other than the player) will automatically sort mail according to the complete set of rules listed below and the mail will be delivered to the next step in the mail route. There is a small chance for each mail item handled to be handled improperly. Mail routed to the player will be added to their stack of mail to sort.

## Mail Generation
Mail is generated by senders and routed to their local post office until the amount of mail sent to the player meets two quotas:
The quota for the number of brand new mail that the player must sort, and
the quota for the total amount of mail the player must sort.
The ruleset of the day governs the type of mail randomly generated the morning prior to the player's workday. e.g., damaged mail is not generated the first day.

Step 1: Story mail generation
Pre-scripted mail is occasionally generated and sent to the player on certain days. Story mail will usually have readable content.

Step 2: Existing mail routed
Mail that was routed to the player by other post offices will appear in their queue.

Step 3: Random mail generation
At the beginning of each day, there is a minimum amount of new mail that must arrive for the player. New mail is generated by senders randomly and forwarded to the appropriate mail router (the sender's local post office) until the amount sent to the player's office meets this quota. There is an additional guota for the total amount of mail the player must have to sort for a day. If this quota is not met, mail generation will continue as before until it is.

The when a sender generates mail, they have a high chance of replying to a letter that was sent to them within the week prior.

# Implementation

## Rules
This is a WIP list of rules. Each day uses some set of them. If a rule is not in effect on a given day, mail matching that rule should be set aside.
For example, if the "Damaged mail must be repaired" rule is not in effect, the player should set aside damaged mail, not deliver it.

Mail must go to recipient: Valid mail must be placed in the recipient's box.
Mail must be routed appropriately: Valid mail not addressed to the player's town must be routed to the appropriate neighboring post office.
Mail must be stamped: Mail without a postal stamp must be RTS as "Postage Due"
Stamps must be sufficient: Mail with a stamp not appropriate for routing to another town must be RTS as "Postage shortpaid"
Damaged mail must be repaired: Damaged mail must be taped up.
Mail must be forwarded as requested: If post is addressed to a recipient's old address, a stamp must be placed to clarify the new address and the mail should be routed there.
Unreturnable mail must be placed in recovery: If mail must be returned to sender, but has no return address, it must be dated and placed in the mail recovery bin.

## Mail Routing
For simplicity, the network formed by the postal offices will always be simply-connected. This means that there is only one path between any two postal offices if backtracking is not allowed. This way, when mail must be routed from one office to another, there is always exactly one valid neighbor to route mail to.

## World Generation
The game world consists of towns, which have locations on the map and zip codes. Each town contains 3-8 streets, each of which has 4-12 homes, and each of those may have 1-3 senders. None of these components have actual locations on the map, they are simply used to generate coherent addresses shown on the mail. This is the alternative to randomly generating the addresses for each individual piece of post. Hopefully, this makes the world feel less abstract.

The player's town is generated with a few dozen senders. This number is designed so that the player comes to recognize their names over time. Four towns are generated within a disk around the player's town, and all are connected to the player's town. One of these four is very large (many senders), one is medium, and two are small. After that, six additional towns are randomly generated outside this disk, and each is connected to the nearest town (but never to the player's town). Each of these towns is in the small-to medium size range.

### Town Generation
Each town randomly genrates a random floating-point value for the number of streets via a normal distribution (mu=5.5, s=0.7). Each does the same to determine the number of houses, with a normal distribution of (mu=8, s=1.3) and each house generates the number of senders with (mu=1.8, s=0.6). Because the product of these value's means approximately govern the town's mean population, the *cube root* of the town size multiplier is multiplied by every random value. These values are then rounded to the nearest integer or up to the minimum value. The minimum number of streets is 2, the minimum number of houses is 2, and the minimum number of senders is 1. Some (~5% of) houses randomly skip sender generation, creating empty houses.

## Settings

### World Generation
**Town Size Multiplier**: The average number of residents in each town is multiplied by this number. At a multiplier of 1, the average town will have 80 residents. (Default: 1)

**Number of Connecting Towns**: The number of towns that generate that are directly connected to the player's town. (Default: 4)

**Number of Additional Towns**: The number of towns that generate which don't connect directly to the player's town. (Default: 6)

### Difficulty

**Mail Multiplier**: The mail quota, new mail quota, and max mail are multiplied by this value.

## Hidden Settings

### World Generation
**min_town_sep**: The minimum allowable distance between two towns during generation.

### Difficulty
**max_mail_mul**: The max mail is multiplied by this value. Can be increased to gauruntee the player handle's all mail without increasing the quota.

## Server Specification

Before a world is generated and mail simulated, Postman must load a server specification folder which has three primary objects:
- A sub-folder called "names" which contains the wordlists from which streets, towns, and people get their names.
- A sub-folder called "story" which contains the specifiaction for the different rulesets and on which days they apply
- A file called "server.json" which specifies settings native to that server

### Server Specification

**mode**: "singleplayer", "multiplayer", or "dedicated multiplayer". In singleplayer, inbound TCP connections are not received and a local player object is automatically created and bound to a thread. Multiplayer allows incoming connections and binds them to threads, but is otherwise the same. Dedicated multiplayer also allows incoming connections, but does not create a local player.

## Day Specification

All days are enumerated in "days.json". All probabilites are given as decimals (i.e. 0.12 = 12%)

**prob_sender_shortpays**: Probability that the mail will have invalid indicia (insufficient/missing stamp). If the due postage is low (sender and recipient are in the same town), this will cause the stamp to be missing. If the postage due is high, there is an equal chance the stamp will be missing or insufficient.

**prob_sender_damages_mail**: Probability that mail will be damaged upon generation.

**prob_router_damages_mail**: Probability that a simulated post office will damage mail. The next post office on the route will have to repair it.

**prob_sender_moves**: Probability that a sender will move to an empty home and make a request to forward mail.

**new_mail_quota**: The amount of brand-new mail the player must handle this day.

**mail_quota**: The amount of mail the player must handle on this day.

**mail_limit**: The maximum amount of mail the player can handle this day.

## Post Office AI
The AI does not actually exist on a post office class or the town class. Actually, the AI is encapsulated in the mail.handle() function, which changes variables within the mail class to allow it to transit.

The mail class maintains three relevant variables; these are the previous, current, and following variables. Each holds a town or a house and allows you to check where the mail was, where it is, and where it is going. When mail is created, previous is set to the sender, current is set to the sender's town, and following is set to None. The purpose of the handle() function is to set value of mail.following. Note that artificial error is introduced at this stage. mail.following is set to where the mail *will* go, not necessarily where it *should* go.

The mail.advance() function moves the mail by updating the variables appropriately.

## Main Loop

The game operates on a central loop of actions outlined below.

1 Day begins

2 If there are any morning sequences due, play them.

3 Prepare the mail queue for each player. This is done by moving mail from the PO's queue to the player's queue as needed. Ideally, all mail for the PO would be handled by the player, but some may be handled automatically to limit the player's workload.

	1 Any mail in the PO's queue marked as story mail is moved to the player's queue
	
	2 Shuffle the PO's queue
	
	2 Move new mail (with age=0) from the PO's queue into the player's queue. Stop when the new mail quota is met, the PO's queue is emptied, or the max mail limit is reached.
	
	3 Move all kinds of mail from the PO's queue into the player's queue. Stop when the mail quota is met, the PO's queue is emptied, or the max mail limit is reached.
	
	4 Generate new mail until the new mail quota and the general mail quota are met.

Note that in actuality, the POs *don't* track the mail in their queue. The function to handle a mail-item is actually a member of the mail class itself as this removes the overhead of having mail items remove themselves from a queue and re-add themselves to a new one each time they change locations. Because of this, the above steps are actually performed by looping over all the mail and moving them to the appropriate player's queue if they pass an enormous conditional statement, which is broken into several conditionals for readability.

## Multiplayer

Each game is a server with which a session can be established by a client. The client creates a **player object** which contacts the server to establish a connection. When the server is contacted, it creates a thread for handling player inputs and forwards messages over this connection to that thread in the form of events added to a queue maintained by the thread. The server also sends information pertinent to each player back to the client over their connection.

### Internal vs. External Communication

The communication between a client player object and a server thread can be either internal or external. In the internal mode, the player object contacts and communicates with the server by calling functions on the game object. Only one such connection can be formed with a postman server. External communications occur over a TCP/IP connection initiated with the server and are authenticated. The server thread converts received messages into equivalent function calls and the connected player object similary processes messages it receives.

### Server Settings

When a postman game is run, it must load server settings (outlined below) from a file. One such setting defines whether the server is singleplayer, multiplayer, or dedicated multiplayer.

A "singleplayer" game prompts the server to disallow external connections and it will not create a TCP socket. Instead, it will create a player object and automatically connect it to a single thread. A default server settings file specifying singleplayer is loaded when you select "New Story" from the main menu.

A "multiplayer" game allows external connections and creates and binds a TCP socket. It also automatically creates a player object and connect it to the server internally. A default server settings file specifying multiplayer is loaded when you select "Multiplayer" > "New Server".

A "dedicated multiplayer" game allows external connections as with multiplayer, but does not create an internally connected client. To create *and play in* such a server, you must launch the game and connect to the server via "Multiplayer" > "Connect to a Server". There is no way to create a dedicated multiplayer server from the base game as there is no option to do so and it does not contain the code to run the headless server GUI. A separate file must be run that loads a server settings file of the user's specification. One such file for a dedicated multiplayer server is provided as it is with the others.

The dedicated server is not wholly justafiable at this time, however an additional multiplayer story could be implemented to justify it so that I can implement this and feel like I'm not wasting effort.

The Diffie-Hellman key exchantge is used to generate a secret key which encrypts all commands sent to a thread, so that the information necessary to send commands to a thread is only held by the thread and the player object that initiated the connection. Each player object initiates a connection prior to map generation via one of two methods; either by sending a message to a TCP port which the game has been configured to listen to or from within the application, by calling a function.

## Postman Protocol

Postman player objects (clients) and interface threads (servers, each bound to 1 client) comminucate via the postman protocol that runs over TCP. A multiplayer game starts one thread that accepts external connections over a socket. The sockets representing individual connections are then passed to newly created threads for handling events and player input.

Each client and server maintains an object that is either a connected TCP socket or an object that implements recv_into() and sendall() such that it can be used as a connected TCP socket, thus circumventing the need for a socket on the loopback interface for singleplayer games.

### Authentication

External connections through TCP are authenticated via 1024-bit RSA. The first thing the game does is generate a public-private RSA key pair and creates an incoming connection-handling thread. This thread opens a socket an listens to incoming connections. As soon as a connection is accepted, the socket which represents the new connection is passed to a function in a new thread with authentication enabled, that manages this connection. The original thread returns to listening for connections. The new thread listens for a request, of which two currently exist: "info" and "join". The former causes the thread to send public server information and destroy itself. The latter begins the authentication procedure.

The join request will have included the public key of the client. The thread immediately responds with the server's public key. From then on, all messages are signed by the sender's private key and encrypted with the recipient's public key. The recipient decrypts and verifies each message. Signatures are generated via PKCS#1 v1.5 (RSA)

### Postman Header

Each number represents a bit. Each line represents 4 bytes.

```
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                 "PST" in ASCII                |    is auth    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                           signature                           |  <- Only present if "is auth" is true.
                               ...
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  <- Below this line, all data is encrypted if "is auth" is true
|           player id           |          request type         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                              data                             |
                               ...
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

"PST": 3 bytes
	The first three bytes are the letters "PST". This uniquely identifies postman packets.

is auth: 1 byte
	The fourth byte is a boolean that represents whether the packet is authenticated. This is taken to be false if the byte is all 0s and True otherwise.
	If this field is false, the packet is valid only if at least one of the following is true:
		- This packet's request does not require authentication, i.e. it is a request to download the game's map.
		- The receiving thread does not expect authentication, i.e. it is a local connection not over a real TCP socket.
	
	If this field is true, the packet is only valid if the receiving thread expects authentication.

signature: 128 bytes
	This field is only present if "is auth" is true. It contains the PKCS#1 1.5 signature of the SHA256 hash of the remainder of the packet.

data: variable
	This field contains the fields associated with the request type as detailed below.

### Requests

Each request has an associated ID, which is what is found in the header "request" field, and a specification for what must appear in the "data" field. The contents of the data field are typically different depending on whether the packet is being sent by the client or server.

#### Info

ID: 1

Description: Request info on a server. This packet can only be sent by unauthenticated clients, i.e. prior to joining the server. Therfore is_auth must always be false. A server will only send an info packet in response to an info packet received by a client.

Data if sent by client: None

Data if sent by server:

```
Not yet implemented
```

#### Join

ID: 2

Description: Begins the process of joining a server. is_auth must be false. 

Data if sent by server: Never sent by the server.

Data if sent by client:

```
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          public key                           |  <- Is actually 128 bytes
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

public key:  128 bytes
	The client's 1024 bit public RSA key. Must be omitted if the connection is not to be authenticated.

#### Map

ID: 3

Description: Sent by the server after a player joins. Includes all towns with their name, zip code, location, and connections. This information can be used to create the player's map. The data field begins with a 2-byte field specifying the number of towns, followed by a 42-byte town descriptor for each town. The total size of the data field in bytes is 2+42\*num_towns. Each town 

Data if sent by client: Never sent by the client.

Data if sent by server:

```
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|           num towns           |         town zip code         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|        town x position        |        town y position        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                           town name                           |
                               ...
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        additional towns                       |
                               ...
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

num towns: 2 bytes
	The number of towns in the map. This field is followed by this many 42-byte town descriptors.

town zip code: 2 bytes
	The town's zip code as an unsigned short.

town x position: 2 bytes
	The town's x position as a signed short.

town y position: 2 bytes
	The town's y position as a signed short.

town name: 32 bytes
	The town's name as a null-terminated string.

## Roadmap

### Version 1.0.0

- Programming
	- Full world generation ✓
	
	- Full mail simulation
		- Mail generation
			- Mail occasionally damaged
			- Mail occasionally has typo'd address (can be sent or RTS'd)
			- Mail occasionally has completely wrong address (must be RTS'd)
			- Mail occasionally has insufficient postage
			- Mail occasionally does not have sender address
		
		- Mail routing ✓
		- Notification of incorrectly routed mail. ✓
		- Notification of routing of damaged mail.
		- Notification of routing mail with due postage.
		- Mail damaged randomly
		- Mail repaired
		- Mail RTS'd w/ "Insufficient Postage", "Cannot be delivered as addressed"
		
		- Senders occasionally submit recovery requests.
		- Recovery requests automatically handled by POs, routed as needed.
		
	- Good looking map
		- Curved town connection lines
		- Placing random art assets in vacant spots
	
	- Client-Server protocol
		- If server settings specify singleplayer, game creates server and player object. Player object contacts server and binds to a thread. The server generates the world and begins playthrough.
	
	- Player Interface
		- Player presented with queue of mail items.
		- Player can route mail
		- Player can set items aside (A way for the player to handle items they have not been trained to handle, will be handled automatically at the end of the day)
		- Player can RTS and stamp with a reason for doing so
		- Player can place RTS's mail that lacks a return address into recovery
		- Player can view the contents of local boxes.
		- Player can open mail

- Art
	- At least passable art for all assets
	- Good-Looking Map
		- Map background
		- Assets for random placement (mountains, hills, lakes? drawn aesthetic)

- Writing
	- Story Mode
	
### Version 1.5.0

- Programming
	- Additional gamemodes
		- Endurance

### Version 2.0.0

- Programming
	- Multiplayer Support
		- Server supports TCP connections for multiplayer games and can create TCP-bound threads
	
	- Multiplayer-based world generation
		- Improve connectivity for uniform experience between 

#### Version 2.5.0

- Programming
	- Dedicated Multiplayer Server Support

- Writing
	- Multiplayer Story Mode

